"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;

var _got = _interopRequireDefault(require("got"));
var _deepMapKeys = _interopRequireDefault(require("deep-map-keys"));
var _bluefeather = require("bluefeather");


var _lodash = require("lodash");


var _Logger = _interopRequireDefault(require("./Logger"));
var _errors = require("./errors");function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}





















const log = _Logger.default.child({
  namespace: 'Tmdb' });


class Tmdb {




  constructor(apiKey /*: string*/, language /*: string*/ = 'en') {
    this.apiKey = apiKey;
    this.language = language;
  }

  // eslint-disable-next-line flowtype/no-weak-types
  async get(resource /*: string*/, parameters /*: QueryType*/ = {}) /*: Object*/{
    // eslint-disable-next-line no-constant-condition
    while (true) {
      const response = await (0, _got.default)('https://api.themoviedb.org/3/' + resource, {
        responseType: 'json',
        searchParams: _objectSpread({
          // eslint-disable-next-line id-match
          api_key: this.apiKey }, (


        parameters /*: Object*/)),

        throwHttpErrors: false });


      if (!String(response.statusCode).startsWith('2')) {
        if (response.headers['x-ratelimit-remaining']) {
          const rateLimitRemaining = Number(response.headers['x-ratelimit-remaining']);

          if (!rateLimitRemaining) {
            const currentTime = Math.round(new Date().getTime() / 1000);
            const rateLimitReset = Number(response.headers['x-ratelimit-reset']);

            // The minimum 30 seconds cooldown ensures that in case 'x-ratelimit-reset'
            // time is wrong, we don't bombard the TMDb server with requests.
            const cooldownTime = Math.max(rateLimitReset - currentTime, 30);

            log.debug('reached rate limit; waiting %d seconds', cooldownTime);

            await (0, _bluefeather.delay)(cooldownTime * 1000);

            // eslint-disable-next-line no-continue
            continue;
          }
        }

        if (response.statusCode === 404) {
          throw new _errors.NotFoundError();
        }

        throw new _errors.RemoteError(response.body.status_message, response.body.status_code);
      }

      return (0, _deepMapKeys.default)(response.body, _lodash.camelCase);
    }
  }

  async getMovie(movieId /*: number*/) /*: Promise<MovieType>*/{
    const movie = await this.get('movie/' + movieId, {
      language: this.language });


    return _objectSpread(_objectSpread({},
    movie), {}, {

      // Revenue can be 0, e.g. https://gist.github.com/gajus/b396a7e1af22977b0d98f4c63a664d44#file-response-json-L94
      revenue: movie.revenue || null,

      // Runtime can be 0, e.g. https://gist.github.com/gajus/b396a7e1af22977b0d98f4c63a664d44#file-response-json-L95
      runtime: movie.runtime || null });

  }

  async getMovieBackdropImages(movieId /*: number*/, includeImageLanguage /*: $ReadOnlyArray<string>*/) /*: Promise<$ReadOnlyArray<MovieBackdropImageType>>*/{
    const movie = await this.get('movie/' + movieId + '/images', {
      include_image_language: includeImageLanguage ? includeImageLanguage.join(',') : null,
      language: this.language });


    return movie.backdrops;
  }

  async getMovieCastCredits(movieId /*: number*/) /*: Promise<$ReadOnlyArray<MovieCastCreditType>>*/{
    const movieCredits = await this.get('movie/' + movieId + '/credits', {
      language: this.language });


    return movieCredits.cast;
  }

  async getMovieCrewCredits(movieId /*: number*/) /*: Promise<$ReadOnlyArray<MovieCrewCreditType>>*/{
    const movieCredits = await this.get('movie/' + movieId + '/credits', {
      language: this.language });


    return movieCredits.crew;
  }

  async getMoviePosterImages(movieId /*: number*/, includeImageLanguage /*: $ReadOnlyArray<string>*/) /*: Promise<$ReadOnlyArray<MoviePosterImageType>>*/{
    const movie = await this.get('movie/' + movieId + '/images', {
      include_image_language: includeImageLanguage ? includeImageLanguage.join(',') : null,
      language: this.language });


    return movie.posters;
  }

  async getMovieVideos(movieId /*: number*/) /*: Promise<$ReadOnlyArray<MovieVideoType>>*/{
    const movie = await this.get('movie/' + movieId + '/videos', {
      language: this.language });


    return movie.results;
  }

  async getPerson(personId /*: number*/) /*: Promise<PersonType>*/{
    const person = await this.get('person/' + personId, {
      language: this.language });


    return person;
  }

  async getCompany(companyId /*: number*/) /*: Promise<CompanyType>*/{
    const company = await this.get('company/' + companyId, {
      language: this.language });


    return company;
  }

  async findId(resourceType /*: 'movie' | 'person'*/, externalSource /*: 'imdb'*/, externalId /*: string*/) /*: Promise<number>*/{
    if (resourceType !== 'movie' && resourceType !== 'person') {
      throw new _errors.Unimplemented();
    }

    if (externalSource !== 'imdb') {
      throw new _errors.Unimplemented();
    }

    const result = await this.get('find/' + externalId, {
      external_source: externalSource + '_id' });


    let results;

    if (resourceType === 'movie') {
      results = result.movieResults;
    } else if (resourceType === 'person') {
      results = result.personResults;
    } else {
      throw new Error('Unexpected state.');
    }

    if (results.length === 0) {
      throw new _errors.NotFoundError();
    }

    if (results.length > 1) {
      throw new _errors.UnexpectedResponseError();
    }

    return Number(results[0].id);
  }}var _default =


Tmdb;exports.default = _default;
//# sourceMappingURL=Tmdb.js.map